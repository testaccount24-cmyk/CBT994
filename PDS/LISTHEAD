LISTHEAD TITLE '- TSO command to list load module eye-catchers.'
         SPACE 1
* ------------------------------------------------------------------- *
***********************************************************************
*                                                                     *
*     LISTHEAD - TSO command to list the eye-catcher, if any, in      *
*           the entry point CSECT of a load module in the normal      *
*           search path.                                              *
*                                                                     *
*           Modified to list more non-standard eye catchers. (SG)     *
*           Modified to give a 3-line hex display. (SG) - 7/19        *
*           Modified to access the entry point or the load point,     *
*               using the keyword ENTRY or by omitting it.            *
*           Modified to give a 4-line hex display. (SG) - 3/24        *
*                                                                     *
*     Register usage:                                                 *
*           R5 - Base.                                                *
*           R6 - Work.                                                *
*           R7 - Work.                                                *
*           R8 - Work.                                                *
*           R9 - Work, Parse PDEs.                                    *
*          R10 - CPPL pointer.                                        *
*          R12 - Base.                                                *
*                                                                     *
*                               Jeffrey R. Broido                     *
*                               25 April 2001                         *
*                                                                     *
*                               Modified by S.Golob  -  4/10          *
*                               Modified by Updater  -  7/14          *
*                               Modified by S.Golob  - 12/16          *
*                               Modified by S.Golob  -  7/19          *
*                               Modified by S.Golob  -  8/19          *
*                               Modified by S.Golob  -  9/19          *
*                                                                     *
*     Change History (of sorts):                                      *
*                                                                     *
*        The original purpose of this program seems to have been,     *
*        to display standard IBM headers in their load modules.       *
*        Traditionally, an IBM-written load module would begin        *
*        with an unconditional branch instruction X'47F0' that        *
*        would branch over a standard-looking eyecatcher which        *
*        told you the name of the module, and its release or PTF      *
*        level.  These headers seem to be what the author of          *
*        this program wanted to display.  ONLY THOSE HEADERS and      *
*        no others.                                                   *
*                                                                     *
*        But things have changed in the IBM world, and the load       *
*        modules which IBM produces, have fully reflected these       *
*        changes.                                                     *
*                                                                     *
*        There are now other instructions which do unconditional      *
*        branches, besides the BC instruction (whose unconditional    *
*        format is X'47F0').  There are JUMP instructions and LARL    *
*        instructions, and there are also BAKR and PR combinations.   *
*        IBM uses all of these, and therefore, this program must      *
*        change to reflect all of this new stuff from IBM.            *
*                                                                     *
*        The program works (currently) by issuing a LOAD macro        *
*        against desired load module, and it searches the first       *
*        few bytes of the loaded module, to see what is there.        *
*                                                                     *
*        If there are branch or jump instructions, then the program   *
*        displays what was branched or jumped over.                   *
*                                                                     *
*        For diagnosis purposes, if you need to investigate near      *
*        the beginning of any module entry point, the program will    *
*        display the first 400 bytes at the load module entry         *
*        point, in 3-line hexadecimal representation.                 *
*                                                                     *
*        If a load module contains multiple modules, each with its    *
*        own header, these are not displayed.  Only the entry point   *
*        header is displayed, or the header at the beginning of the   *
*        module is displayed, if the ENTRY keyword was not used.      *
*                                                                     *
*        Sometimes a program is coded with comments at the beginning  *
*        and the entry point, off the beginning, points to a BAKR     *
*        instruction, or something similar, with the (non-executable) *
*        comments at the beginning.  The LOAD macro does not return   *
*        the address of these comments, and at the present time       *
*        therefore, they cannot be displayed.  If the entry point     *
*        is a BAKR instruction, the program was changed to say so.    *
*        Hope this helps a bit more than before.  (SBG - June 2014)   *
*                                                                     *
*        Updated by Updater (July 20, 2014):                          *
*        Process now adjusted to load the entire module, even if the  *
*        entry point is not at the beginning.  This takes care of     *
*        "almost normal" modules from SYS1.VTAMLIB and such, with     *
*        the entry point just AFTER the eyecatcher.  The command      *
*        previously would not therefore show such an eyecatcher.      *
*        So the command was modified to find the address at the       *
*        beginning of the module, even if the entry point officially  *
*        was later.  If you want to display the entry point alone,    *
*        then use the ENTRY keyword after the module name:            *
*                                                                     *
*                 example:    LISTHEAD modname ENTRY                  *
*                                                                     *
*        Please note that the HEX display will show all hex values    *
*        in "printable" format, so you don't need any other tools     *
*        to see the first 400 bytes of the load modules, displayed    *
*        in a 3-line hexadecimal display.                             *
*                                                                     *
*        For some modules, such as IEBCOPY, you have to use the       *
*        ENTRY parameter to get a realistic eyecatcher.  You'll       *
*        have to try both ways with some modules, to see which        *
*        way shows the beginning of the module more realistically.    *
*                                                                     *
*        If you want to see a hex display of the entire module, or    *
*        from the entry point to the end of the module, use the       *
*        LISTMOD program, which is a derivative of this program.      *
*        (CBT File 423 or 994).                                       *
*                                                                     *
*        Updated by Sam Golob (December 12, 2016):           *DEC-2016*
*        Updated by Sam Golob again (June 2, 2019)                    *
*           (Made 3-line hex display instead of raw data)             *
*        Updated by Sam Golob again (September 2019)                  *
*                                                                     *
*        Added a few extra keywords to limit the display:             *
*                                                                     *
*         NOHEX   - Leaves out the hex display of the first 400       *
*                   bytes of the module.                              *
*         NOTITLE - Leaves out the line telling you which module      *
*                   got loaded.                                       *
*                                                                     *
*        Executing with NOHEX and NOTITLE produces the result that    *
*        this program used to produce, before it was modified.        *
*                                                                     *
*        Accounted for possible NOOP instructions at the beginning    *
*        of the program, before the branch over the header.           *
*                                                                     *
*        Fixed bug in EPUTL to GETMAIN SP=0 and FREEMAIN SP=0         *
*                                                                     *
*     CHANGES:  2020/02/03 - SBG                                      *
*               Changed ruler to go from 0 to 99 instead of           *
*               from 1 to 100.  It had been one byte off.             *
*                                                                     *
*               2024/03/04 - SBG                    *SBG*2024         *
*               Make the hex display 400 bytes, because some          *
*               headers are very long, but on the other hand,         *
*               don't display the hex by default, so the display      *
*               isn't so big.  HEX is now not the default, but        *
*               it can be deployed for purposes of diagnosis.         *
*                                                                     *
*               During the TITLE display, show what keywords are      *
*               available to the program, and which of them are       *
*               the defaults (if no keywords are coded).              *
*               Suggest the HEX display if you have a non-standard    *
*               header.                                               *
*                                                                     *
*     CHANGES:  2024/07/28 - CBT                                      *
*               Load from tasklib if TASKLIB DDNAME is allocated.     *
*                                                                     *
***********************************************************************
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
         MACRO                         Display hex numbers
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         STM   R15,R1,HEXSAVE          Save work registers.
         LA    R1,&FROM                From location
         LA    R0,&LEN                 Length to display
         LA    R15,&TO                 Where to display
         BAL   R4,HEX                  Do it.
         LM    R15,R1,HEXSAVE          Restore work registers.
         MEND
* ------------------------------------------------------------------- *
LISTHEAD AMODE 31                  Display load module headers.
LISTHEAD RMODE ANY
LISTHEAD CSECT
         SPACE 1
         SPACE 1
         YREGS
         USING LISTHEAD,R15        (ESTABLISH TEMPORARY BASE).
         B     BEGIN               SKIP OVER HEADER.
HEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.
HEAD     DC    C'LISTHEAD - &SYSDATE - &SYSTIME  '
HEADL    EQU   *-HEAD
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         LR    R12,R15             COPY BASE.
         USING LISTHEAD,R12,R5     (TELL ASSEMBLER).
         LA    R5,4095(,R12)
         LA    R5,1(,R5)
         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.
         LA    R13,SAVE            POINT TO MY SAVE AREA.
         ST    R14,SAVE+4          CHAIN ...
         ST    R13,8(,R14)         ... SAVE AREAS.
         SPACE 1
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD
         MVC   BLANKS,BLANKS-1       WITH BLANKS
         MVC   MEMBER,BLANKS       Initialize member name with blanks.
         LR    R10,R1              PRESERVE CPPL POINTER.
         XC    FLAG3,FLAG3
         USING CPPL,R10            (TELL ASSEMBLER)
         SR    R1,R1                                             *TASK*
         ST    R1,OPENDCB                                        *TASK*
         SPACE 1
***********************************************************************
*                                                                     *
*        Initialize the Parse Parameter List and call TSO Parse.      *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.
         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.
         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.
         DROP  R10                                               *TASK*
         SPACE 1
         LA    R1,PPL              POINT TO THE PPL.
         XC    ECB,ECB             CLEAR ECB.
         CALLTSSR EP=IKJPARS       PARSE INPUT.
         ST    R15,SAVPARCD        SAVE RETURN CODE.
         L     R9,ANS              POINT TO PDES.
         USING PDL,R9              TELL ASSEMBLER.
         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.
         BCTR  R1,*-*              DECREMENT LENGTH.
         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.
         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL
*      ( MVC   MEMBER(*-*),0(R15)  )
         MVC   ENTRYOP,ENTRYKW     COPY PDE'S
         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*
         MVC   NOTITOP,NOTITKW                               *DEC-2016*
         MVC   HEXOP,HEXKW
         MVC   TITOP,TITKW
         CLI   HEXOP+1,1           Make NOHEX the default    *SBG*2024
         BE    GODISPLY            Let HEX override if there *SBG*2024
         OI    NOHEXOP+1,1         Make NOHEX the default    *SBG*2024
*                                  DON'T DO IKJRLSA
GODISPLY DS    0H
         MVI   LINE-1,X'40'        INITIALIZE DISPLAY AREA
         L     R15,SAVPARCD        RETURN CODE FROM IKJPARS
         LTR   R15,R15             INVALID PARAMETER ?
         BNZ   HELPMSG             GO ISSUE HELP MSG AND EXIT.
         DROP  R9
         CLI   NOTITOP+1,1         NOTITLE?
         BE    NOTIT1              YES, SKIP DISPLAY OF TITLE.
         MVC   LINE,LINE-1
         MVC   LINE(22),=C'Loaded Program Name:  '
         MVC   LINE+22(8),MEMBER
         CLI   ENTRYOP+1,1
         BNE   PUTTIT01
         MVC   LINE+42(13),=C'(Entry Point)'
         B     PUTTIT02
PUTTIT01 DS    0H
         MVC   LINE+42(12),=C'(Load Point)'
PUTTIT02 DS    0H
         APUT  LINE,60
NOTIT1   DS    0H                  Print a line of dashes
         CLI   NOHEXOP+1,1         If NOHEX keyword
         BE    LPA0                Then don't print dashes
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
NOTIT2   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*        Fetch the user-specified load module.                        *
*                                                                     *
***********************************************************************
* ------------------------------------------------------------------- *
*    We first ask if the module is from LPA, and if not, then we      *
*    LOAD it.                                                         *
* ------------------------------------------------------------------- *
*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD "LOAD" FOR     *
*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *
*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *
*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE "ENTRY"   *
*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *
* ------------------------------------------------------------------- *
LPA0     DS    0H
         LA    R10,TASKDCB                                       *TASK*
         MVC   DEVDDNAM,DCBDDNAM-IHADCB(R10) 'TASKLIB'           *TASK*
         DEVTYPE DEVDDNAM,DEVDATA                                *TASK*
         LTR   R15,R15             IF NO TASKLIB DD              *TASK*
         BNZ   NOTASK                LEAVE R10 AS ZERO           *TASK*
         MVI   OPENL,X'80'                                       *TASK*
         LA    R1,OPENL                                          *TASK*
         OPEN  ((R10),(INPUT)),MF=(E,(1))                        *TASK*
         TM    DCBOFLGS-IHADCB(R10),DCBOFOPN                     *TASK*
         BO    LOAD0                                             *TASK*
NOTASK   SR    R10,R10                                           *TASK*
         ST    R10,OPENDCB                                       *TASK*
         LM    R0,R1,MEMBER       Load member name for IEAVVMSR
         STM   R7,R8,LPAREGS      Save registers
         L     R3,16              CVT
         L     R15,352(,R3)       CVTLPDSR
         BALR  R14,R15            CALL IEAVVMSR
         B     LPAINFO            MODULE IS IN LPA, GET LPDE.
         B     LOAD0              NOT IN LPA, TRY LOADING IT.
LPAINFO  DS    0H
         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.
         LM    R7,R8,LPAREGS      RESTORE REGISTERS
         LR    R6,R0              SAVE LPDE ADDRESS
         ST    R6,LPDEADDR        And store it for reporting
         L     R9,16(,R6)         GET ENTRY POINT ADDRESS
         N     R9,=X'7FFFFFFF'    Get rid of high bit.
         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT
         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?
         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.
         OI    FLAG2,X'02'        Mark this one as an alias.
         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.
         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.
MAJLPDE  DS    0H
         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.
         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator
         ST    R9,ADRSTART        Start of the full data of the module
         ST    R9,SAVER9A         Save it in another place
         ST    R9,SAVER9C         SAVE THE LOAD POINT.
         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.
         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE
         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE
         L     R2,SAVER9B         GET THE ENTRY POINT
         L     R3,SAVER9C         SUBTRACT THE LOAD POINT
         SR    R2,R3              GET THE DISPLACEMENT
         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD
         ST    R2,STORDIFF        SAVE THE DISPLACEMENT
         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD
* ------------------------------------------------------------------- *
         SPACE 1
LOAD0    DS    0H
         ST    R10,OPENDCB        SAVE DCB ADDRESS FOR CLOSE     *TASK*
         LM    R7,R8,LPAREGS      RESTORE REGISTERS
         LOAD  EPLOC=MEMBER,DCB=(R10),ERRET=LOAD1  FETCH MODULE  *TASK*
*    Put in a display of x number of bytes at the load point, here.
LOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?
         BZ    LOAD2               B IF YES; CONTINUE.
*              SAY: CANNOT LOAD MEMBER.
         MVC   LINE,LINE-1
         MVC   LINE(MSG002L),MSG002
         APUT  LINE,MSG002L
         LA    R15,8               SET CC = 8.
         ST    R15,SAVER15A        SAVE THE RETURN CODE
         B     EXIT                EXIT.
LOAD2    DS    0H
         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.
         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations
         ST    R9,ADRSTART         Start of the full data of the module
         ST    R9,SAVER9A          Save load module data address
         ST    R9,SAVER9B          Save it again in another place
         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary
         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*
         ST    R3,SAVER3B          Save R3
         LR    R3,R1               Get length in doublewords
         SLL   R3,3                Convert to bytes
         ST    R3,SAVER3A          SAVE ORIGINAL LENGTH
         L     R3,SAVER3B          Restore R3
         SLL   R1,3                COMPUTE LENGTH IN BYTES   *JUL-2014*
         ST    R1,LOADLEN          SAVE MAX DISPLAY LENGTH   *JUL-2014*
         MVC   LOADWHOL,LOADLEN    Save it again
* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*
* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*
* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*
* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*
* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*
* THE END OF THE MODULE.                                     *JUL-2014*
*        CLI   ENTRYOP+1,1         IF ENTRY OR EP KEYWORD    *JUL-2014*
*        BE    KEEPR9              SKIP THE NEW CODE         *JUL-2014*
* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*
* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*
* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*
* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*
* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*
         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*
         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*
         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*
         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*
* ------------------------------------------------------------------- *
*              The correct CDE might not be the last one,             *
*             so chain back until you've got a name match.            *
* ------------------------------------------------------------------- *
CDELOOP  DS    0H                  Check if CDE matches member name
         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)
         BE    CDEEND              Yes, then process it.
         CLC   FULLZERO,0(R14)     Back at the beginning of the chain
         BE    CDEBAD                without a match? Then error.
         L     R14,0(,R14)         No match. Go back one previous CDE.
         B     CDELOOP             Keep trying till match or first CDE
*                                    without a match.
CDEBAD   DS    0H
         MVC   LINE,LINE-1         Error message if beginning of CDE
         MVC   LINE(MSG003L),MSG003  was reached without a name match.
         APUT  LINE,MSG003L
         B     EXIT12              Code 12 for this one.
CDEEND   DS    0H
         ST    R14,CDEADDR         Store address of CDE found.
         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*
         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*
         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*
MAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*
         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         ST    R0,SAVER9C
         CR    R9,R0                                         *JUL-2014*
         BL    KEEPR9                                        *JUL-2014*
         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*
         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*
         ST    R0,SAVER1B
         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         ST    R0,SAVER9D
         CR    R9,R0                                         *JUL-2014*
         BNL   KEEPR9                                        *JUL-2014*
         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         LR    R9,R0                                         *JUL-2014*
         ST    R9,SAVER9E
* ------------------------------------------------------------------- *
*            COME HERE FOR BOTH LPA AND LOADED MODULES                *
* ------------------------------------------------------------------- *
ENTRYPM  DS    0H                  Check if entry point is displaced.
         L     R2,SAVER9B          Get entry point of module
         L     R3,SAVER9C          Get beginning addr of module
         SR    R2,R3               Calculate difference in length
         BNP   ENTRYPM1            Do a LOAD if number is not reliable
         ST    R2,STORDIFF         Save the entry point displacement.
*
ENTRYPM0 DS    0H
         LTR   R2,R2               Is then entry point displacement 0?
         BZ    NODIFF              Then do the whole module.
*
ENTRYPM1 DS    0H                  It is different, then calculate.
         L     R1,LOADWHOL         Entire length from LOAD macro
         MVC   SAVER3A,LOADWHOL    Save it.
         S     R1,STORDIFF         Subtract offset of entry point
         ST    R1,LOADSMAL         Preserve reduced load length
         MVC   SAVER3B,LOADSMAL    Save short length for later
         B     YESDIFF             Yes, entry point diff from load pt
KEEPR9   EQU   *                                             *JUL-2014*
*
NODIFF   DS    0H                  Go here if entry pt is load point
         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end
         MVC   SAVER3B,LOADSMAL    Save size from entry point to end
         L     R1,LOADWHOL         Load R1 with size
         OI    FLAG1,X'01'         Flag load point equal entry point
         L     R9,ADRSTART         Load R9 with data address
*
YESDIFF  DS    0H
         TM    FLAG1,X'01'         Load point different from entry pt?
         BZ    ENTRYDIF            No. Skip this section.
         L     R1,LOADWHOL         Start R1 with whole size.
         ST    R1,LOADLEN          And store it in LOADLEN.
         L     R9,ADRSTART         Load R9 with data address
* ------------------------------------------------------------------- *
ENTRYDIF DS    0H                  Display of Diagnostic Data
         ST    R9,SAVER9A          SAVE THE PROGRAM DATA
         CLI   NOTITOP+1,1         NOTITLE coded?
         BE    KEEPR9A             Yes. Then skip this display.
         MVC   LINE,LINE-1
         MVC   LINE(28),=C'Length  of loaded module:     '
         HEX   LINE+28,4,SAVER3A
         MVC   LINE+41(11),=C'Load point:'
         HEX   LINE+54,4,SAVER9C
         STM   R14,R1,SAVE14T1
         APUT  LINE,65
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(25),=C'Entry Point Displacement:'
         HEX   LINE+28,4,STORDIFF
         MVC   LINE+40(12),=C'Entry point:'
         HEX   LINE+54,4,SAVER9B
         STM   R14,R1,SAVE14T1
         APUT  LINE,65
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(48),=C'Use keywords: HEX, NOHEX, TITLE, NOTITLE, ENX
               TRY.'
         STM   R14,R1,SAVE14T1
         APUT  LINE,50
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(27),=C'Defaults are: NOHEX, TITLE.'
         STM   R14,R1,SAVE14T1
         APUT  LINE,27
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(39),=C'Use HEX to display the first 400 bytes,'
         STM   R14,R1,SAVE14T1
         APUT  LINE,39
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(41),=C'especially if the header is non-standard.'
         STM   R14,R1,SAVE14T1
         APUT  LINE,41
         LM    R14,R1,SAVE14T1
KEEPR9A  DS    0H
*
         ST    R0,LADRSAVE
         CLI   NOHEXOP+1,1         IF NOHEX KEYWORD          *DEC-2016*
         BE    NODASH1             THEN DON'T PRINT HEX TITLE
         MVC   LINE,LINE-1         PRINT THE HEX DISPLAY TITLE
         MVC   LINE(65),=C'First 400 bytes of Loaded Storage (load modux
               le e.p. + 400 bytes):'
         APUT  LINE,70
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
NODASH1  DS    0H                                            *DEC-2016*
* ------------------------------------------------------------------- *
*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *
* ------------------------------------------------------------------- *
ENTRYPRM DS    0H                  Process the ENTRY keyword here.
         CLI   ENTRYOP+1,1         Entry keyword not there?
         BNE   BIGMOD              Go treat whole module.
         L     R9,SAVER9B          Data address at entry point
         ST    R9,SAVER9A          Store address away for display.
         L     R1,LOADSMAL         Load reduced size, e.p. to end.
         ST    R1,LOADLEN          Store that length for display
         B     SMALLMOD            Don't display the whole module.
BIGMOD   DS    0H
         L     R9,SAVER9C          Address of beginning of the data.
         ST    R9,SAVER9A          Store address away for display.
         L     R1,LOADWHOL         Load the full size of the module.
         ST    R1,LOADLEN          Store that length for display
*        MVC   LOADLEN,LOADWHOL
*              IF THE MODULE SIZE < 64 THEN DON'T SHOW 64
SMALLMOD DS    0H
         ST    R9,SAVER9A          Save pointer to the data.
         CLI   NOHEXOP+1,1         If NOHEX keyword
         BE    JUST1               Then skip all the hex printing.
* ------------------------------------------------------------------- *
*              PREPARE FOR HEX DISPLAY OF ONE LINE                    *
* ------------------------------------------------------------------- *
HEXIT    DS    0H
         L     R9,SAVER9A          Reload address of the data
*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100
         L     R1,LOADLEN          Get module length in bytes
         CH    R1,=H'100'          Less than 100?
         BNH   *+8                 Yes, skip limit to 100.
         LH    R1,=H'100'          No. Just print 100 at a time
         BCTR  R1,0                One less for execute.
         ST    R1,SAVER1A          Save the length - 1
         BAL   R7,PRTXLINE         Print these 100 bytes in hex
* ------------------------------------------------------------------- *
*                       DISPLAY SECOND LINE                           *
* ------------------------------------------------------------------- *
         L     R9,SAVER9A          Reload address of the data
         LA    R9,100(,R9)         Skip 100 bytes from current
         L     R1,LOADLEN          Get module length in bytes
         S     R1,=F'100'          Subtract 100
         BNP   JUST1               Finished? Stop the process.
         CH    R1,=H'100'          Less than 100 bytes left?
         BNH   *+8                 Yes. Use the current value
         LH    R1,=H'100'          No. Limit the print to 100 bytes.
         BCTR  R1,0                One less for execute.
         ST    R1,SAVER1A          Save the length - 1
         BAL   R7,PRTXLINE         Print these 100 bytes in hex
* ------------------------------------------------------------------- *
*                        DISPLAY THIRD LINE                           *
* ------------------------------------------------------------------- *
         L     R9,SAVER9A          Reload address of the data
         LA    R9,200(,R9)         Skip 200 bytes from current
         L     R1,LOADLEN          Get module length in bytes
         S     R1,=F'200'          Subtract 200
         BNP   JUST1               Finished? Stop the process.
         CH    R1,=H'100'          Less than 100 bytes left?
         BNH   *+8                 Yes. Use the current value
         LH    R1,=H'100'          No. Limit the print to 100 bytes.
         BCTR  R1,0                One less for execute.
         ST    R1,SAVER1A          Save the length - 1
         BAL   R7,PRTXLINE         Print these 100 bytes in hex
* ------------------------------------------------------------------- *
*                        DISPLAY FOURTH LINE                          *
* ------------------------------------------------------------------- *
         L     R9,SAVER9A          Reload address of the data
         LA    R9,300(,R9)         Skip 300 bytes from current
         L     R1,LOADLEN          Get module length in bytes
         S     R1,=F'300'          Subtract 300
         BNP   JUST1               Finished? Stop the process.
         CH    R1,=H'100'          Less than 100 bytes left?
         BNH   *+8                 Yes. Use the current value
         LH    R1,=H'100'          No. Limit the print to 100 bytes.
         BCTR  R1,0                One less for execute.
         ST    R1,SAVER1A          Save the length - 1
         BAL   R7,PRTXLINE         Print these 100 bytes in hex
* ------------------------------------------------------------------- *
*                      END OF HEX DISPLAY                             *
* ------------------------------------------------------------------- *
*      NOW CHECK TO SEE IF THERE IS SOME KIND OF STANDARD HEADER      *
* ------------------------------------------------------------------- *
JUST1    EQU   *                   CHECK FOR INITIAL INSTRUCTIONS
         L     R9,SAVER9A          Point to the data to check it.
* ------------------------------------------------------------------- *
*        ARE THERE LEADING NOOPS OR NULL BRANCHES OF ANY KIND?        *
* ------------------------------------------------------------------- *
         LA    R6,0                INITIALIZE R6 FOR LIMITING DISPLAY
SKIPLOOP DS    0H                  SKIP ANY NOOP INSTRUCTIONS
         MVC   WORKINST(8),0(R9)   MOVE 8 BYTES TO WORK AREA
         CLC   =X'A704',WORKINST   IS THIS A JUMP NOOP?
         BNE   TRYMOR01            NO. NEXT TRY.
         LA    R9,4(,R9)           ADVANCE 4 BYTES
         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER
         B     SKIPLOOP            TRY IF MORE NOOPS
TRYMOR01 DS    0H                  IS THIS A BRANCH NOOP?
         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA
         NC    WORKINST(2),=X'FFF0'  IGNORE INDEX REGISTER
         CLC   =X'4700',WORKINST   CHECK IF BRANCH NOP TO ANYWHERE
         BNE   TRYMOR02            NO. NEXT TRY.
         MVC   WORKINST(8),0(R9)   YES. RELOAD WORK AREA
         LA    R9,4(,R9)           ADVANCE 4 BYTES
         LA    R6,4(,R6)           SUBTRACT 4 BYTES PAST HEADER
         B     SKIPLOOP            TRY IF MORE NOOPS.
TRYMOR02 DS    0H                  IS THIS A BR NOOP?
         MVC   WORKINST(8),0(R9)   RELOAD WORK AREA
         NC    WORKINST(2),=X'FFF0'  IGNORE DESTINATION REGISTER
         CLC   =X'0700',WORKINST   IS IT A NOPR?
         BNE   TRYMORE             NO. NEXT TRY.
         LA    R9,2(,R9)           ADVANCE 2 BYTES
         LA    R6,2(,R6)           SUBTRACT 2 BYTES PAST HEADER
         B     SKIPLOOP            TRY IF MORE NOOPS.
TRYMORE  DS    0H
*
*    CHECK FIRST FOR LARL AT THE BEGINNING OF THE MODULE..........  SBG
*    CHECK ALSO FOR BRANCH AND SAVE AT THE BEGINNING..............  SBG
*
         CLC   =X'0D',0(R9)        IS BEGINNING OF MODULE BAS?
         BNE   TRYLARL             NO. TRY LARL.
         LA    R9,2(,R9)           BUMP PAST BAS.
         LA    R6,2(,R6)
         B     TRYNORML            CHECK IF NORMAL LABEL IS THERE.
TRYLARL  DS    0H
         CLC   =X'C0300000',0(R9)  LARL?                            SBG
         BNE   TRYNORML            NO. REGULAR PROCESSING.          SBG
         LA    R9,6(,R9)           BUMP PAST STUFF.                 SBG
         LA    R6,6(,R6)
TRYNORML DS    0H
         CLC   =X'47F0',0(R9)      POSSIBLY STANDARD HEADER?
         BE    LOAD3               B IF YES; CONTINUE.
         CLC   =X'05F047F0',0(R9)  POSSIBLY STANDARD HEADER?
         BNE   TRYNORMZ            NO. TRY NEW JUMP INSTRUCTION.    SBG
         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.
         LA    R6,2(,R6)
         B     LOAD3               CONTINUE.
TRYNORMZ DS    0H
         CLC   =X'47FF',0(R9)      POSSIBLY STANDARD HEADER?
         BE    LOAD3               B IF YES; CONTINUE.
         CLC   =X'05F047FF',0(R9)  POSSIBLY STANDARD HEADER?
         BNE   TRYA7               NO. TRY NEW JUMP INSTRUCTION.    SBG
         LA    R9,2(,R9)           YES. BUMP LOAD MODULE ORIGIN.
         LA    R6,2(,R6)
         B     LOAD3               CONTINUE.
TRYA7    DS    0H
         CLC   =X'A7F4',0(R9)      IS IT BRC UNCONDITIONAL?
         BNE   TRYSTMF             B IF NOT.  ERROR.
         MVC   WORKHALF(2),2(R9)   GET NUMBER OF HALFWORDS
         L     R8,WORKFULL         LOAD REGISTER WITH THEM
         SLL   R8,1                MULTIPLY BY 2 TO GET BYTES
         B     BRANCHA7            CONTINUE PROCESSING NORMALLY
TRYSTMF  DS    0H                  TRY STORE MULTIPLE FIRST
         MVC   WORK08(8),0(R9)     X'90ECD00C05B047F0'
         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE
         CLC   =X'90ECD00C050047F0',WORK08     Example: AMDPRFMT
         BNE   TRYLR
         LA    R9,6(,R9)           Get to the 47F0.
         LA    R6,6(,R6)           Eliminate stuff at beginning.
         OI    FLAG3,X'01'         Kludge flag for this header.
         B     TRYNORML            Look at regular 47F0 from here.
TRYLR    DS    0H                  TRY STORE MULTIPLE FIRST
         MVC   WORK08(8),0(R9)     X'90ECD00C18xf47F0'
         NI    WORK08+5,X'0F'      NULLIFY BASE REG FOR COMPARE
         CLC   =X'90ECD00C180F47F0',WORK08     Example: IEBGENER
         BNE   NONSTD
         LA    R9,6(,R9)           Get to the 47F0.
         LA    R6,6(,R6)           Eliminate stuff at beginning.
         OI    FLAG3,X'01'         Kludge flag for this header.
         B     TRYNORML            Look at regular 47F0 from here.
NONSTD   DS    0H
*                         SAY: LOAD MODULE HAS NON-STANDARD HEADER.
         CLI   NOTITOP+1,1         Displaying titles?
         BE    NOSTDASH            No. Skip dashes to be more readable
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
NOSTDASH DS    0H                  Display 'non-std header' message.
         MVC   LINE,LINE-1
         MVC   LINE(MSG001L),MSG001
         APUT  LINE,MSG001L
         LA    R15,4               SET CC = 4.
         ST    R15,SAVER15A        SAVE THE RETURN CODE
         B     EXIT                EXIT.
LOADA7   DS    0H
LOAD3    DS    0H
*        B     LOAD5         TEST TEST TEST
*        SR    R8,R8               CLEAR INSERT REGISTER AND ...
*        ICM   R8,B'0001',3(R9)    ... LOAD HEADER LENGTH.
*        BZ    LOAD4               B IF BYTE LENGTH IS ZERO.
LOAD5    DS    0H
* --->
         MVC   WORKHALF(2),2(R9)   PUT FULL Fhhh VALUE IN WORKAREA
         NI    WORKHALF,X'0F'      GET RID OF REGISTER, LEAVING NUMBER
LOAD5A   DS    0H
*
*        MVC   LINE,LINE-1
*        HEX   LINE,2,WORKHALF
*        APUT  LINE,10
*
         L     R8,WORKFULL         LOAD R8 BACK WITH NUMBER
         TM    FLAG3,X'01'
         BZ    BRANCHA7
         LA    R8,6(,R8)           KLUDGE
BRANCHA7 DS    0H
         SR    R8,R6               SPACE TAKEN BY LEADING NULL BRANCHES
         C     R8,=F'200'          BIGGER THAN 200?
         BNH   LOADHALF            NO, JUST LOAD NUMBER ITSELF
         L     R8,=F'200'          YES, LOAD 200 TO LIMIT SIZE TO MOVE
LOADHALF DS    0H
         ST    R8,SAVER8A
*        MVC   LINE,LINE-1
*        HEX   LINE,4,SAVER8A
*        APUT  LINE,10
* --->
HEADOUT  DS    0H                  Now display the load module header.
         L     R8,SAVER8A
         S     R8,=F'5'
         BNP   EXIT0
         STC   R8,MOVEIC
         CLI   NOTITOP+1,1         If we don't display titles,
         BE    NOTIT3              Then skip this title for the header.
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
         MVC   LINE,LINE-1
         CLI   ENTRYOP+1,1  Differentiate between load pt and entry pt
         BNE   LOADPT01
         MVC   LINE(36),=C'Load Module Header at Entry Point:  '
         B     LOADPT02
LOADPT01 DS    0H
         MVC   LINE(36),=C'Load Module Header at Load Point:   '
LOADPT02 DS    0H
         APUT  LINE,40
NOTIT3   DS    0H                  Now display the header itself.
         MVC   LINE,LINE-1
         EX    R8,MVHEAD           MOVE HEADER TO LINE.
         STM   R14,R1,SAVE14T1
         APUT  LINE,200            Put the data out.
         LM    R14,R1,SAVE14T1
         LA    R15,0
         ST    R15,SAVER15A        SAVE THE RETURN CODE
         B     EXIT0               EXIT WITH CC = 0.
EXIT12   LA    R15,12
         ST    R15,SAVER15A        SAVE THE RETURN CODE
         B     EXIT
EXIT0    SR    R15,R15             SET CC = 0.
         ST    R15,SAVER15A        SAVE THE RETURN CODE
EXIT     L     R10,OPENDCB         POINT TO DCB                  *TASK*
         LTR   R10,R10             IS DCB OPEN                   *TASK*
         BZ    EXITX               NO, BRANCH                    *TASK*
         MVI   CLOSEL,X'80'                                      *TASK*
         LA    R1,CLOSEL                                         *TASK*
         CLOSE ((R10)),MF=(E,(1))                                *TASK*
EXITX    L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.
         TM    FLAG2,X'01'
         BO    WASLPA
         DELETE EP=MEMBER
WASLPA   DS    0H
         L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.
         L     R15,SAVER15A        GET THE RETURN CODE
         ST    R15,16(,R13)
         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.
         L     R14,12(,R13)        RELOAD RETURN ADDRESS.
         BR    R14                 RETURN TO CALLER.
* ------------------------------------------------------------------- *
*                          HEX DISPLAY                                *
* ------------------------------------------------------------------- *
PRTXLINE DS    0H                Print 4 lines in ISPF HEX format
         ST    R7,SAVER7A            Plus a fifth ruler line.
         MVC   LINE,LINE-1
         L     R1,SAVER1A
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         L     R1,SAVER1A          RELOAD THE LENGTH
         B     *+10
TRHEXL0  TR    LINE(*-*),TRTBL0    MAKE A PRINTABLE LINE
         EX    R1,TRHEXL0
         APUT  LINE,100
         MVC   LINE,LINE-1
         L     R1,SAVER1A          RELOAD THE LENGTH
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         B     *+10
TRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY
         EX    R1,TRHEXL1
         APUT  LINE,100
         MVC   LINE,LINE-1         RELOAD THE LENGTH
         L     R1,SAVER1A
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         B     *+10
TRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY
         EX    R1,TRHEXL2
         APUT  LINE,100
         MVC   LINE,LINE-1
         L     R1,SAVER1A          RELOAD LENGTH
*                                  APUT DESTROYS R1.
         B     *+10
         MVC   LINE(0),RULERL      MOVE DATA TO PRINT LINE
         EX    R1,*-6
         APUT  LINE,100
         L     R7,SAVER7A
         BR    R7
* ------------------------------------------------------------------- *
HELPMSG  DS    0H
         STM   R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         MVC   LINE(37),=C'-------------------------------------'
         APUT  LINE,37
         MVC   LINE,LINE-1
         MVC   LINE(37),=C'Syntax: LISTHEAD modname (parameters)'
         APUT  LINE,37
         MVC   LINE,LINE-1
         MVC   LINE(10),BLANKS
         APUT  LINE,10
         MVC   LINE,LINE-1
         MVC   LINE(37),=C'Parameters:  ENTRY, NOTITLE, NOHEX   '
         APUT  LINE,37
         MVC   LINE,LINE-1
         MVC   LINE(37),=C'-------------------------------------'
         APUT  LINE,37
         LM    R14,R1,SAVE14T1
         LA    R15,4               Make return code 4.
         B     EXIT
* ------------------------------------------------------------------- *
         TITLE '- Static data area.'
SAVE     DS    9D                  SAVE AREA.
CVDWORK  DS    D                   CVD work area
LADRSAVE DS    D
LOADLEN  DS    F                                             *JUL-2014*
LPAREGS  DS    2F
LOADWHOL DS    F                   Entire size of load module
LOADSMAL DS    F                   Distance from entry point to end.
STORDIFF DS    F                   Displacement of entry point.
ENTRYOP  DS    F                                             *JUL-2014*
NOHEXOP  DS    F                                             *DEC-2016*
NOTITOP  DS    F                                             *DEC-2016*
HEXOP    DS    F                                             *DEC-2016*
TITOP    DS    F                                             *DEC-2016*
SAVE14T1 DS    4F
ADRENTRY DS    F
ADRSTART DS    F
LPDEADDR DS    F
CDEADDR  DS    F
SAVPARCD DS    F
SAVER1A  DS    F
SAVER1B  DS    F
SAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE
SAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1
SAVER3A  DS    F
SAVER3B  DS    F
SAVER3C  DS    F
SAVER6A  DS    F
SAVER7A  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER10A DS    F
SAVER15A DS    F
DISPR8A  DS    F
WORK08   DS    CL8
MAJNAME  DS    CL8
DEVDDNAM DS    D                                                 *TASK*
DEVDATA  DS    2F                                                *TASK*
OPENDCB  DS    F                                                 *TASK*
OPENL    DS    F                                                 *TASK*
CLOSEL   DS    F                                                 *TASK*
TASKDCB  DCB   DDNAME=TASKLIB,DSORG=PO,MACRF=R                   *TASK*
FLAG1    DS    X                   X'01' if entry point at beginning
FLAG2    DS    X                   X'01' if LPA module
FLAG3    DS    X                   X'01' if need to kludge header size
MASK10   DC    XL10'40202020202020202120'
WORKINST DS    2F                   COPY OF INSTRUCTION
MOVEIC   DC    X'00'
DASHES   DS    0CL65
DASHEZ   DC    65C'-'
         DS    CL1
BLANKS   DS    CL65' '
FULLZERO DC    F'0'
         SPACE 1
*IOPL     DS    0A                  IOPL FOR PUTLINE.
*IOPLUPT  DS    A                   POINTER TO USER PROFILE TABLE.
*IOPLECT  DS    A                   POINTER TO ENVIRONMENT CONTROL TAB.
*IOPLECB  DC    A(ECB)              POINTER TO ECB.
*IOPLIOPB DC    A(PTPB)             POINTER TO PTPB.
         SPACE 1
         SPACE 1
*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.
         SPACE 1
MVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***
MVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***
RULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x
               -+----6----+----7----+----8----+----9----+----'
         DS    CL1
LINE     DS    CL200
         SPACE 1
         LTORG
WORKFULL DS    0F
         DC    H'0'
WORKHALF DC    H'0'
         TITLE '- MESSAGES.'
MSG001   DC    C'Load module has non-standard header.'
MSG001L  EQU   *-MSG001
         SPACE 1
MSG002   DC    C'Cannot load '
MEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.
         DC    C' from any library in normal search path.'
MSG002L  EQU   *-MSG002
MSG003   DC    C'Beginning of CDE chain reached without a name match.'
MSG003L  EQU   *-MSG003
         TITLE '- Parse parameters.'
PPL      DS    0A                  PARSE PARM LIST.
PPLUPT   DS    A                   POINT TO UPT.
PPLECT   DS    A                   POINT TO ECT.
PPLECB   DC    A(ECB)              POINT TO ECB.
PPLPCL   DC    A(PCL)              POINT TO PCL.
PPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.
PPLCBUF  DS    A                   POINT TO COMMAND BUFFER.
PPLWA    DC    A(0)                NO WORK AREA.
         SPACE 1
ANS      DS    A                   ANSWER PLACE.
ECB      DC    A(0)                COMMAND PROCESSOR ECB.
PCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.
PDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +
               PROMPT='Load Module+',MAXLNTH=8,                        +
               HELP=('Name of load module to be listed.')
ENTRYKW  IKJKEYWD ,
         IKJNAME 'ENTRY'
NOHEXKW  IKJKEYWD ,
         IKJNAME 'NOHEX'
NOTITKW  IKJKEYWD ,
         IKJNAME 'NOTITLE'
HEXKW    IKJKEYWD ,
         IKJNAME 'HEX  '
TITKW    IKJKEYWD ,
         IKJNAME 'TITLE'
         IKJENDP
HEX      DS    0H
         ST    R4,SAVER4A
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         L     R4,SAVER4A
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
SAVER4A  DS    F
HEXSAVE  DS    3F                    Register save for HEX macro
         DS    CL1
TRTBL0   DS    0D
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'404040404040404040404A4B4C4D4E4F'
         DC    XL16'504040404040404040405A5B5C5D5E5F'
         DC    XL16'606140404040404040406A6B6C6D6E6F'
         DC    XL16'404040404040404040407A7B7C7D7E7F'
         DC    XL16'40818283848586878889404040404040'
         DC    XL16'40919293949596979899404040404040'
         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'
         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'
TRTBL1   DS    0D
         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'
         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'
         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'
         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'
         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'
         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'
         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'
         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'
         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'
         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'
         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'
         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'
         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'
         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'
         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'
         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'
TRTBL2   DS    0D
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         TITLE '- Mapping DSECTs.'
         PRINT GEN
         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.
         CVT   DSECT=YES
         IKJTCB                                              *JUL-2014*
         IHACDE                                              *JUL-2014*
         IHAXTLST                                            *JUL-2014*
         PRINT NOGEN                                         *TASK*
         DCBD  DSORG=PO                                      *TASK*
         END   LISTHEAD
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*  CLEANED A BIT  . . . 08/17
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUMENTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
R3       EQU   3                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         EJECT
         IHAPSA   LIST=YES                                     HD APR88
         EJECT                                                 HD APR88
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
         DS    0D
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   R14,R12,12(R13)    SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES,SP=0       RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    R1,8(,R13)         OUR SAVE AREA POINTER
         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA
         LR    R13,R1             @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(,R13)        POINT TO CALLER'S RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 RC IF BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 RC IF BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(,RML)              MESSAGE LENGTH
         STH   R15,PUTLEN               PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA
         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    R2,R13                   @OUR SAVE AREA
         LR    R3,R15                   SAVE RETURN CODE
         L     R13,4(,R13)              @CALLER'S SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,R3                   RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END   EPUTL
