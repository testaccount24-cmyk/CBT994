LISTMODD TITLE '- TSO command to list load module in hex format'
         SPACE 1
* ------------------------------------------------------------------- *
***********************************************************************
*                                                                     *
*     LISTMODD - TSO command to list an entire module in ISPF-like    *
*               hexadecimal format.  Width of the display is          *
*               112 bytes wide, so that a wide screen is preferable.  *
*                                                                     *
*               Displacements of data are marked in decimal.          *
*                                                                     *
*               Using the ENTRY parameter, the display goes from      *
*               the entry point until the physical end of the module. *
*               Otherwise, the display includes the entire module     *
*               from beginning to end.                                *
*                                                                     *
*     Register usage:                                                 *
*           R5 - Base.                                                *
*           R6 - Work.                                                *
*           R7 - Work.                                                *
*           R8 - Work.                                                *
*           R9 - Work, Parse PDEs.                                    *
*          R10 - CPPL pointer.                                        *
*          R12 - Base.                                                *
*                                                                     *
*     Ideas in the program were developed by Jeffrey Broido and       *
*     Bill Godfrey.  The program was adapted for dumping load         *
*     modules, by Sam Golob.                                          *
*                                                                     *
*     Partial description of the program:  Display the bytes of       *
*     a load module in ISPF-like 3-line hexadecimal format, with      *
*     ruler to help measure and locate particular bytes.              *
*                                                                     *
*     The program works (currently) by first testing if the module    *
*     is in the Link Pack Area (LPA).  If so, then the LPDE is        *
*     looked up, to obtain the relevant information.  If the program  *
*     is not in LPA, then a LOAD macro is issued to obtain the        *
*     information.                                                    *
*                                                                     *
*     The program either displays the entire load module, or,         *
*     using the ENTRY parameter, it starts with the entry point,      *
*     and it dumps the contents of the rest of the load module,       *
*     in 3-line hex format with ruler, to see what is there.          *
*                                                                     *
*     All the bytes of the program are displayed, if there is no      *
*     parameter.  If the ENTRY parameter is used, then all the        *
*     bytes from the entry point to the end of the module, are        *
*     displayed.                                                      *
*                                                                     *
*              example:    LISTMODD modname ENTRY                     *
*                                                                     *
*     Please note that the HEX display will show all hex values       *
*     in "printable" format, so you don't need any other tools        *
*     to see the contents of the load modules, displayed in a         *
*     3-line hexadecimal display with added ruler.                    *
*                                                                     *
*     For some modules, such as IEBCOPY, you have to use the          *
*     ENTRY parameter to see a realistic eyecatcher.  But since       *
*     (with IEBCOPY and with many other load modules) the entry       *
*     point is in the middle of the load module, LISTMODD will        *
*     then (using the ENTRY keyword) only list the bytes from         *
*     the entry point location until the end of the module.           *
*                                                                     *
*     CHANGES:  2020/02/03 - SBG                                      *
*               Changed ruler to go from 0 to 99 instead of           *
*               from 1 to 100.  It had been one byte off.             *
*     CHANGES:  2024/05/07 - CBT                                      *
*               Load from tasklib if TASKLIB DDNAME is allocated.     *
*                                                                     *
***********************************************************************
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
*      PRODUCE A "DISPLAY REPRESENTATION" OF HEXADECIMAL NUMBERS      *
* ------------------------------------------------------------------- *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         STM   R15,R1,HEXSAVE
         LA    R1,&FROM
         LA    R0,&LEN
         LA    R15,&TO
         BAL   R4,HEX
         LM    R15,R1,HEXSAVE
         MEND
* ------------------------------------------------------------------- *
*                   BEGINNING OF THE PROGRAM                          *
* ------------------------------------------------------------------- *
LISTMODD AMODE 31
LISTMODD RMODE ANY
LISTMODD CSECT
         SPACE 1
         SPACE 1
         YREGS
         USING LISTMODD,R15        (ESTABLISH TEMPORARY BASE).
         B     BEGIN               SKIP OVER HEADER.
HEAD0    DC    AL1(HEADL)          EXCLUSIVE LENGTH OF HEADER.
HEAD     DC    C'LISTMODD - &SYSDATE - &SYSTIME  '
HEADL    EQU   *-HEAD
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         LR    R12,R15             COPY BASE.
         USING LISTMODD,R12,R5     SET UP BASE REGISTERS.
         LA    R5,4095(,R12)
         LA    R5,1(,R5)
         LR    R14,R13             COPY CALLER'S SAVE AREA POINTER.
         LA    R13,SAVE            POINT TO MY SAVE AREA.
         ST    R14,SAVE+4          CHAIN ...
         ST    R13,8(,R14)         ... SAVE AREAS.
         SPACE 1
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVI   BLANKS-1,X'40'      FILL THE BLANKS FIELD
         MVC   BLANKS,BLANKS-1       WITH BLANKS
         MVC   MEMBER,BLANKS       Initialize member name with blanks.
         LR    R10,R1              PRESERVE CPPL POINTER.
         MVC   MAJNAME,BLANKS
         USING CPPL,R10            (TELL ASSEMBLER)
         SR    R1,R1                                             *TASK*
         ST    R1,OPENDCB                                        *TASK*
         SPACE 1
***********************************************************************
*                                                                     *
*        Initialize the Parse Parameter List and call TSO Parse.      *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   PPLUPT,CPPLUPT      COPY UPT ADDRESS.
         MVC   PPLECT,CPPLECT      COPY ECT ADDRESS.
         MVC   PPLCBUF,CPPLCBUF    COPY COMMAND BUFFER ADDRESS.
         DROP  R10                                               *TASK*
         SPACE 1
         LA    R1,PPL              POINT TO THE PPL.
         XC    ECB,ECB             CLEAR ECB.
         CALLTSSR EP=IKJPARS       PARSE INPUT.
         LTR   R15,R15             Check return code from IKJPARS
         BNZ   HELPMSG             Not zero, Help message and end.
         L     R9,ANS              POINT TO PDES.
         USING PDL,R9              TELL ASSEMBLER.
         LH    R1,PDLLM+4          LOAD LENGTH OF LOAD MODULE NAME.
         BCTR  R1,*-*              DECREMENT LENGTH.
         L     R15,PDLLM           POINT TO RETURNED MEMBER NAME.
         EX    R1,MVMEM            COPY MEMBER NAME FROM PDL
*      ( MVC   MEMBER(*-*),0(R15)  )
         MVC   ENTRYOP,ENTRYKW
         MVC   NOHEXOP,NOHEXKW                               *DEC-2016*
         MVC   HEXOP,HEXKW
*        MVC   NOTITOP,NOTITKW                               *DEC-2016*
         MVI   FLAG1,X'00'             Initialize flag.
         MVC   STORDIFF,=X'00000000'   Assume the entry point at 0.
FREEPDES IKJRLSA ANS               FREE THE PDES.
*        CLI   NOTITOP+1,0                                   *DEC-2016*
*        BNE   NOTIT2                                        *DEC-2016*
         MVC   LINE,LINE-1
         MVC   LINE(22),=C'Loaded Program Name:  '
         MVC   LINE+22(8),MEMBER
         APUT  LINE,40
NOTIT1   DS    0H                                            *DEC-2016*
*        CLI   NOHEXOP+1,0         IF NOHEX KEYWORD          *DEC-2016*
*        BNE   LPA0
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
NOTIT2   DS    0H                                            *DEC-2016*
         SPACE 1
***********************************************************************
*                                                                     *
*              FETCH THE USER-SPECIFIED LOAD MODULE.                  *
*                                                                     *
***********************************************************************
* ------------------------------------------------------------------- *
*    LOGIC OF THE PROGRAM WAS CHANGED TO DO A STANDARD "LOAD" FOR     *
*    THE MODULE REQUESTED, BUT TO AFTERWARDS, ALSO CALCULATE THE      *
*    MODULE ENTRY POINT IN THE DIFFERENT WAYS POSSIBLE, AND TO SAVE   *
*    ALL THE RESULTS.  AFTERWARDS, DEPENDING ON WHETHER THE "ENTRY"   *
*    PARAMETER WAS CODED, THE RESULTS ARE DISPLAYED ACCORDINGLY.      *
* ------------------------------------------------------------------- *
*    We first ask if the module is from LPA, and if not, then we      *
*    LOAD it.                                                         *
* ------------------------------------------------------------------- *
LPA0     DS    0H
         LA    R10,TASKDCB                                       *TASK*
         MVC   DEVDDNAM,DCBDDNAM-IHADCB(R10) 'TASKLIB'           *TASK*
         DEVTYPE DEVDDNAM,DEVDATA                                *TASK*
         LTR   R15,R15             IF NO TASKLIB DD              *TASK*
         BNZ   NOTASK                LEAVE R10 AS ZERO           *TASK*
         MVI   OPENL,X'80'                                       *TASK*
         LA    R1,OPENL                                          *TASK*
         OPEN  ((R10),(INPUT)),MF=(E,(1))                        *TASK*
         TM    DCBOFLGS-IHADCB(R10),DCBOFOPN                     *TASK*
         BO    LOAD0                                             *TASK*
NOTASK   SR    R10,R10                                           *TASK*
         ST    R10,OPENDCB                                       *TASK*
         LM    R0,R1,MEMBER       Load member name for IEAVVMSR
         STM   R7,R8,LPAREGS      Save registers
         L     R3,16              CVT
         L     R15,352(,R3)       CVTLPDSR
         BALR  R14,R15            CALL IEAVVMSR
         B     LPAINFO            MODULE IS IN LPA, GET LPDE.
         B     LOAD0              NOT IN LPA, TRY LOADING IT.
LPAINFO  DS    0H
         OI    FLAG2,X'01'        FLAG THE MODULE AS AN LPA MODULE.
         LM    R7,R8,LPAREGS      RESTORE REGISTERS
         LR    R6,R0              SAVE LPDE ADDRESS
         ST    R6,LPDEADDR        And store it for reporting
         L     R9,16(,R6)         GET ENTRY POINT ADDRESS
         N     R9,=X'7FFFFFFF'    Get rid of high bit.
         ST    R9,SAVER9B         SAVE MODULE ENTRY POINT
         TM    X'1C'(R6),X'04'    IS THIS A MINOR LPDE (ALIAS)?
         BZ    MAJLPDE            NO. PROCESS AS A MAJOR.
         OI    FLAG2,X'02'        Mark this one as an alias.
         MVC   MAJNAME(8),X'20'(R6)  Copy the major name for report.
         L     R6,X'14'(,R6)      YES. GET ADDRESS OF MAJOR LPDE.
MAJLPDE  DS    0H
         L     R9,X'24'(,R6)      GET MODULE LOAD POINT.
         N     R9,=X'7FFFFFFF'    Remove the 31-bit indicator
         ST    R9,ADRSTART        Start of the full data of the module
         ST    R9,SAVER9A         Save it in another place
         ST    R9,SAVER9C         SAVE THE LOAD POINT.
         L     R9,X'20'(,R6)      GET THE SIZE OF THE LOAD MODULE.
         ST    R9,LOADLEN         SAVE THE ENTIRE SIZE
         MVC   LOADWHOL,LOADLEN   COPY WHOLE SIZE
         L     R2,SAVER9B         GET THE ENTRY POINT
         L     R3,SAVER9C         SUBTRACT THE LOAD POINT
         SR    R2,R3              GET THE DISPLACEMENT
         BNP   ENTRYPM1           GO TO SAME CALC AS WITH LOAD
         ST    R2,STORDIFF        SAVE THE DISPLACEMENT
         B     ENTRYPM0           GO TO THE SAME CALC AS WITH LOAD
* ------------------------------------------------------------------- *
LOAD0    DS    0H                 NOT IN LPA. LOAD THE MODULE.
         ST    R10,OPENDCB        SAVE DCB ADDRESS FOR CLOSE     *TASK*
         LM    R7,R8,LPAREGS      RESTORE REGISTERS
         LOAD  EPLOC=MEMBER,DCB=(R10),ERRET=LOAD1  FETCH MODULE  *TASK*
*    Put in a display of x number of bytes at the load point, here.
LOAD1    LTR   R15,R15             WAS LOAD SUCCESSFUL?
         BZ    LOAD2               B IF YES; CONTINUE.
*              SAY: CANNOT LOAD MEMBER.
         MVC   LINE,LINE-1
         MVC   LINE(MSG002L),MSG002
         APUT  LINE,MSG002L
         LA    R15,8               SET CC = 8.
         B     EXIT                EXIT.
LOAD2    DS    0H
         LR    R9,R0               POINT TO LOAD MODULE TO BE LISTED.
         N     R9,=X'7FFFFFFF'     Get rid of high bit for calculations
         ST    R9,ADRSTART         Start of the full data of the module
         ST    R9,SAVER9A          Save it in another place
         ST    R9,SAVER9B          Save it again in another place
         NC    SAVER9B(4),=A(X'7FFFFFFF')  Maybe not necessary
         N     R1,=A(X'00FFFFFF')  ISOLATE LENGTH IN DWORDS  *JUL-2014*
         ST    R3,SAVER3B          Save R3 to restore later
         LR    R3,R1               Get length in doublewords
         SLL   R3,3                Convert to bytes (multiply by 8)
         ST    R3,SAVER3A          Save length in bytes
         L     R3,SAVER3B          Restore original R3
         SLL   R1,3                Do the same for R1        *JUL-2014*
         ST    R1,LOADLEN          And save the max display length
         MVC   LOADWHOL,LOADLEN    Save it again
* ------------------------------------------------------------------- *
* NOTE: IF THE 'ENTRY' KEYWORD IS SPECIFIED, AND THE         *JUL-2014*
* ENTRY POINT IS NEAR THE END OF THE MODULE, THERE MAY BE    *JUL-2014*
* FEWER BYTES THAN THE LOADLEN VALUE FROM THE ENTRY POINT    *JUL-2014*
* TO THE END OF THE MODULE. AS A RESULT, THE DISPLAY OF      *JUL-2014*
* LOADLEN BYTES MIGHT INCLUDE THE CONTENTS OF MEMORY BEYOND  *JUL-2014*
* THE END OF THE MODULE.                                     *JUL-2014*
* IF THE LAST CDE IN JOB PACK AREA QUEUE IS FOR A MODULE     *JUL-2014*
* THAT CONTAINS THE ENTRY POINT ADDRESS IN R9, USE THE       *JUL-2014*
* ADDRESS OF THE MODULE INSTEAD OF THE ENTRY POINT.          *JUL-2014*
* NOTE: COULD ALSO USE LOADPT= ON THE LOAD MACRO, BUT        *JUL-2014*
* MVS 3.8 SYSTEMS DON'T HAVE LOADPT=.                        *JUL-2014*
* ------------------------------------------------------------------- *
*       CALCULATE THE ENTRY POINT ADDRESS OF THE LOAD MODULE          *
*              THIS CODE IS NOW, ALWAYS EXECUTED.                     *
* ------------------------------------------------------------------- *
         N     R9,=A(X'7FFFFFFF')                            *JUL-2014*
         L     R14,540             PSATOLD -> CURRENT TCB    *JUL-2014*
         L     R14,TCBJSTCB-TCB(,R14) POINT TO JOB STEP TCB  *JUL-2014*
         L     R14,TCBJPQ-TCB(,R14) PNT TO LAST CDE IN JPAQ  *JUL-2014*
* ------------------------------------------------------------------- *
*              The correct CDE might not be the last one,             *
*             so chain back until you've got a name match.            *
* ------------------------------------------------------------------- *
CDELOOP  DS    0H                  Check if CDE matches member name
         CLC   MEMBER(8),8(R14)    Is this the correct CDE? (match)
         BE    CDEEND              Yes, then process it.
         CLC   FULLZERO,0(R14)     Back at the beginning of the chain
         BE    CDEBAD                without a match? Then error.
         L     R14,0(,R14)         No match. Go back one previous CDE.
         B     CDELOOP             Keep trying till match or first CDE
*                                    without a match.
CDEBAD   DS    0H
         MVC   LINE,LINE-1         Error message if beginning of CDE
         MVC   LINE(MSG003L),MSG003  was reached without a name match.
         APUT  LINE,MSG003L
         B     EXIT12              Code 12 for this one.
CDEEND   DS    0H
         ST    R14,CDEADDR
         TM    CDATTR-CDENTRY(R14),CDMIN TEST FOR MINOR CDE  *JUL-2014*
         BZ    MAJCDE              BRANCH IF MAJOR CDE       *JUL-2014*
         L     R14,CDXLMJP-CDENTRY(,R14) POINT TO MAJOR CDE  *JUL-2014*
         OI    FLAG2,X'20'        Mark as CDE of an alias.
         MVC   MAJNAME(8),X'8'(R14)     REAL NAME OF MODULE
MAJCDE   L     R14,CDXLMJP-CDENTRY(,R14) POINT TO EXTENT     *JUL-2014*
         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         ST    R0,SAVER9C
         CR    R9,R0                                         *JUL-2014*
         BL    KEEPR9                                        *JUL-2014*
         L     R0,XTLMSBLA-XTLST(,R14) LENGTH OF MODULE      *JUL-2014*
         N     R0,=A(X'7FFFFFFF')                            *JUL-2014*
         ST    R0,SAVER1B
         A     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         ST    R0,SAVER9D
         CR    R9,R0                                         *JUL-2014*
         BNL   KEEPR9                                        *JUL-2014*
         L     R0,XTLMSBAD-XTLST(,R14) ADDRESS OF MODULE     *JUL-2014*
         LR    R9,R0                                         *JUL-2014*
         ST    R9,SAVER9E
* ------------------------------------------------------------------- *
*            COME HERE FOR BOTH LPA AND LOADED MODULES                *
* ------------------------------------------------------------------- *
ENTRYPM  DS    0H                  Check if entry point is displaced.
         L     R2,SAVER9B          Get entry point of module
         L     R3,SAVER9C          Get beginning addr of module
         SR    R2,R3               Calculate difference in length
         BNP   ENTRYPM1            Number is not reliable
         ST    R2,STORDIFF         Save the entry point displacement.
ENTRYPM0 DS    0H
         LTR   R2,R2               Is it zero?
         BZ    NODIFF              Then do the whole module.
ENTRYPM1 DS    0H
         L     R1,LOADWHOL         Load length from LOAD macro
         MVC   SAVER3A,LOADWHOL
         S     R1,STORDIFF         Subtract offset of entry point
         ST    R1,LOADSMAL         Preserve reduced load length
         MVC   SAVER3B,LOADSMAL    Save short length for later
         B     YESDIFF             Yes, entry point diff from load pt
KEEPR9   DS    0H
*
NODIFF   DS    0H                  Go here if entry pt is load point
         MVC   LOADSMAL,LOADWHOL   Size is from beginning to end
         MVC   SAVER3B,LOADSMAL    Save size from entry point to end
         L     R1,LOADWHOL         Load R1 with size
         OI    FLAG1,X'01'         Flag load point equal entry point
         L     R9,ADRSTART         Load R9 with data address
*
YESDIFF  DS    0H
         TM    FLAG1,X'01'         Load point different from entry pt?
         BZ    ENTRYDIF            No. Skip this section.
         L     R1,LOADWHOL         Start R1 with whole size.
         ST    R1,LOADLEN          And store it in LOADLEN.
         L     R9,ADRSTART         Load R9 with data address
* ------------------------------------------------------------------- *
ENTRYDIF DS    0H                  Display of Diagnostic Data
         ST    R9,SAVER9A          SAVE THE PROGRAM DATA
*        CLI   NOTITOP+1,0
*        BNE   KEEPR9A
         TM    FLAG2,X'20'
         BO    NOTLPA00
         TM    FLAG2,X'01'
         BO    MARKLPA
NOTLPA00 DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(23),=C'Module has been LOADED.'
         MVC   LINE+24(13),=C'CDE Address: '
         HEX   LINE+37,4,CDEADDR
         TM    FLAG2,X'20'
         BZ    MARKCDEA
         MVC   LINE+47(10),=C'Alias of: '
         MVC   LINE+57(8),MAJNAME
MARKCDEA DS    0H
         STM   R14,R1,SAVE14T1
         APUT  LINE,75
         LM    R14,R1,SAVE14T1
         B     MOREDSPL
MARKLPA  DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(23),=C'Module is from LPA.    '
         MVC   LINE+21(14),=C'LPDE Address: '
         HEX   LINE+35,4,LPDEADDR
         TM    FLAG2,X'02'
         BZ    MARKLPAA
         MVC   LINE+46(10),=C'Alias of: '
         MVC   LINE+56(8),MAJNAME
MARKLPAA DS    0H
         STM   R14,R1,SAVE14T1
         APUT  LINE,65
         LM    R14,R1,SAVE14T1
MOREDSPL DS    0H
         MVC   LINE,LINE-1
         HEX   LINE+30,4,SAVER3A
         MVC   LINE(30),=C'Length of loaded module Hex:  '
         L     R3,SAVER3A
         CVD   R3,CVDWORK          Convert to Decimal
         MVC   LINE+42(9),=C'Decimal: '
         MVC   LINE+52(10),MASK10
         ED    LINE+52(10),CVDWORK+3
         STM   R14,R1,SAVE14T1
         APUT  LINE,75
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         HEX   LINE+30,4,LOADSMAL
         MVC   LINE(30),=C'Length after entry address :  '
         L     R3,LOADSMAL
         CVD   R3,CVDWORK          Convert to Decimal
         MVC   LINE+42(9),=C'Decimal: '
         MVC   LINE+52(10),MASK10
         ED    LINE+52(10),CVDWORK+3
         STM   R14,R1,SAVE14T1
         APUT  LINE,75
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1
         HEX   LINE+30,4,STORDIFF
         MVC   LINE(30),=C'Displacement of entry point:  '
         L     R3,STORDIFF
         CVD   R3,CVDWORK          Convert to Decimal
         MVC   LINE+42(9),=C'Decimal: '
         MVC   LINE+52(10),MASK10
         ED    LINE+52(10),CVDWORK+3
         STM   R14,R1,SAVE14T1
         APUT  LINE,75
         LM    R14,R1,SAVE14T1
         MVC   LINE,LINE-1             Test diagnostics display.
         HEX   LINE,4,SAVER9A
         HEX   LINE+10,4,SAVER9B
         HEX   LINE+20,4,SAVER9C
         HEX   LINE+30,4,SAVER9D
         HEX   LINE+40,4,SAVER9E
         HEX   LINE+50,4,LOADSMAL
         HEX   LINE+60,4,LOADWHOL
         HEX   LINE+70,4,STORDIFF
         HEX   LINE+80,4,ADRSTART
         HEX   LINE+90,4,SAVER1B
         HEX   LINE+100,1,FLAG1
*        STM   R14,R1,SAVE14T1
*        APUT  LINE,105
*        LM    R14,R1,SAVE14T1
KEEPR9A  DS    0H
*
         CLI   NOHEXOP+1,0                                   *DEC-2016*
         BNE   JUST1                                         *DEC-2016*
         MVC   LINE,LINE-1         Print a line of dashes
         MVC   LINE(65),DASHES
         APUT  LINE,65
NODASH1  DS    0H                                            *DEC-2016*
* ------------------------------------------------------------------- *
*              PREPARE FOR HEX DISPLAY OF ALL LINES                   *
* ------------------------------------------------------------------- *
ENTRYPRM DS    0H                  Process the ENTRY keyword here.
         CLI   ENTRYOP+1,0         Entry keyword not there?
         BE    BIGMOD              Go treat whole module.
         L     R9,SAVER9B          Data address at entry point
         L     R1,LOADSMAL         Load reduced size, e.p. to end.
         B     SMALLMOD            Don't display the whole module.
BIGMOD   DS    0H
         L     R9,SAVER9C          Address of beginning of the data.
         L     R1,LOADWHOL         Load the full size of the module.
*              IF THE MODULE SIZE < 100 THEN DON'T SHOW 100
SMALLMOD DS    0H
         LR    R10,R1              Save length for calculation
         ST    R1,SAVER1L          Store it for printing
LATENTRY DS    0H
         ST    R10,SAVER10A        Store it for safety
* ------------------------------------------------------------------- *
*            Calculate how many lines we will need to print.          *
* ------------------------------------------------------------------- *
         SRDA  R10,32(0)           Set up divide
         D     R10,=F'100'         Divide by 100 decimal
         LTR   R10,R10             Even division?
         BZ    NOREMNDR            Yes. Don't compensate for remainder
         LA    R11,1(,R11)         Add 1 to compensate for remainder
*                                    and print a partial line.
NOREMNDR DS    0H
         XR    R8,R8               Initialize byte counter
* ------------------------------------------------------------------- *
*                     Print All The Lines                             *
* ------------------------------------------------------------------- *
PRNTLOOP DS    0H
*   R1 has quantity SAVER1L in it here.
         C     R1,=F'100'          Less than 100?
         BNH   *+8                 Yes, skip limit to 100.
         L     R1,=F'100'          No. Just print 100 at a time
         BCTR  R1,0                One less for execute.
         STM   R14,R1,SAVE14T1     Protect registers used by APUT
         MVC   LINE,LINE-1
         ST    R1,SAVER1A
         APUT  LINE,4,SAVER1A
         LM    R14,R1,SAVE14T1
*   R1 has quantity SAVER1P in it here.
         ST    R1,SAVER1P          Save the length - 1
         STM   R14,R1,SAVE14T1     Protect registers used by PRTXLINE
         L     R1,SAVER1P          Save the length - 1
         BAL   R7,PRTXLINE         Print these 100 bytes in hex
         LM    R14,R1,SAVE14T1
*   DISPLAY LATER LINES
         LA    R9,100(,R9)         Skip 100 bytes from current
         L     R1,SAVER1L          Reload remaining data length
         S     R1,=F'100'          Subtract 100
         BNP   JUST1               Finished? Stop the process.
         ST    R1,SAVER1L          Decremented length
         BCT   R11,PRNTLOOP
* ------------------------------------------------------------------- *
*                      END OF HEX DISPLAY                             *
* ------------------------------------------------------------------- *
JUST1    DS    0H                  CHECK FOR INITIAL INSTRUCTIONS
         CLI   NOHEXOP+1,0
         BE    NODASH01
         MVC   LINE,LINE-1
         MVC   LINE(65),DASHES
         APUT  LINE,65
NODASH01 DS    0H
         TM    FLAG2,X'01'
         BO    WASLPA
         DELETE EPLOC=MEMBER
WASLPA   DS    0H
*
EXIT0    SR    R15,R15             SET CC = 0.
         ST    R15,SAVER15A        SAVE THE RETURN CODE
EXIT     L     R10,OPENDCB         POINT TO DCB                  *TASK*
         LTR   R10,R10             IS DCB OPEN                   *TASK*
         BZ    EXITX               NO, BRANCH                    *TASK*
         MVI   CLOSEL,X'80'                                      *TASK*
         LA    R1,CLOSEL                                         *TASK*
         CLOSE ((R10)),MF=(E,(1))                                *TASK*
EXITX    L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.
         LM    R0,R12,20(R13)      RELOAD MOST OF CALLER'S REGISTERS.
         L     R14,12(,R13)        RELOAD RETURN ADDRESS.
         BR    R14                 RETURN TO CALLER.
EXIT12   LA    R15,12
         ST    R15,SAVER15A        SAVE THE RETURN CODE
         B     EXIT
* ------------------------------------------------------------------- *
*                     HEX DISPLAY SUBROUTINE                          *
* ------------------------------------------------------------------- *
PRTXLINE DS    0H                  4-line hex printout routine.
         ST    R7,SAVER7A
         ST    R8,SAVER8A
         CVD   R8,CVDWORK          The line number of bytes so far
         MVC   LINE,LINE-1
         L     R1,SAVER1P          Length of line to print
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         L     R1,SAVER1P          RELOAD THE LENGTH
         B     *+10
TRHEXL0  TR    LINE(*-*),TRTBL0    Make the line of printables
         EX    R1,TRHEXL0
         MVC   LINE+100(10),MASK10     Print counter after 1st line
         MVC   LINE+110(2),=C'00'      Show it in hundreds
         ED    LINE+100(10),CVDWORK+3  Plug the number in
         APUT  LINE,112            Print the line of printables
         MVC   LINE,LINE-1
         L     R1,SAVER1P          Reload the length of the line
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         B     *+10
TRHEXL1  TR    LINE(*-*),TRTBL1    HIGH NIBBLE IN HEX DISPLAY
         EX    R1,TRHEXL1
         APUT  LINE,100
         MVC   LINE,LINE-1
         L     R1,SAVER1P          Reload the length of the line
         B     *+10
         MVC   LINE(0),0(R9)       MOVE DATA TO PRINT LINE
         EX    R1,*-6
         B     *+10
TRHEXL2  TR    LINE(*-*),TRTBL2    LOW NIBBLE IN HEX DISPLAY
         EX    R1,TRHEXL2
         APUT  LINE,100
         MVC   LINE,LINE-1
         L     R1,SAVER1P          Reload the length of the line
*                                  since APUT destroys R1.
         B     *+10
         MVC   LINE(0),RULERL      Print the ruler line
         EX    R1,*-6
         APUT  LINE,100
         LA    R8,1(,R8)           Increment counter (x 100)
         L     R7,SAVER7A
         BR    R7
* ------------------------------------------------------------------- *
HELPMSG  DS    0H
         STM   R14,R1,SAVE14T1
         APUT  '-------------------------------------------------',49
         APUT  'Correct usage of LISTMODD is as follows:  ',42
         APUT  '   ',3
         APUT  '  LISTMODD modname (optional parameters)  ',42
         APUT  '   ',3
         APUT  'Parameters are:  NOHEX and ENTRY      ',39
         APUT  '   ',3
         APUT  'Required is the name of the module to load.',43
         APUT  '   ',3
         APUT  'Leaving out parameters produces the hex display',47
         APUT  '  from the beginning of the module.  ENTRY starts',49
         APUT  '  the display from the entry point of the module.',49
         APUT  '   ',3
         APUT  '  NOHEX prints the header information only.      ',49
         APUT  '-------------------------------------------------',49
         STM   R14,R1,SAVE14T1
         B     EXIT
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
         TITLE '- Static data area.'
* ------------------------------------------------------------------- *
SAVE     DS    9D                  SAVE AREA.
CVDWORK  DS    D                   CVD work area
LOADLEN  DS    F
LPAREGS  DS    2F
LOADWHOL DS    F                   Entire size of load module
LOADSMAL DS    F                   Distance from entry point to end.
STORDIFF DS    F                   Displacement of entry point.
ENTRYOP  DS    F
NOHEXOP  DS    F
NOTITOP  DS    F
HEXOP    DS    F
TITOP    DS    F
SAVE14T1 DS    4F
ADRENTRY DS    F
ADRSTART DS    F
LPDEADDR DS    F
CDEADDR  DS    F
SAVER1A  DS    F
SAVER1B  DS    F
SAVER1L  DS    F                   HOLDS DECREMENTED LENGTH OF MODULE
SAVER1P  DS    F                   HOLDS LENGTH OF PRINTED LINE - 1
SAVER3A  DS    F
SAVER3B  DS    F
SAVER3C  DS    F
SAVER7A  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER10A DS    F
SAVER15A DS    F
MAJNAME  DS    CL8
DEVDDNAM DS    D                                                 *TASK*
DEVDATA  DS    2F                                                *TASK*
OPENDCB  DS    F                                                 *TASK*
OPENL    DS    F                                                 *TASK*
CLOSEL   DS    F                                                 *TASK*
TASKDCB  DCB   DDNAME=TASKLIB,DSORG=PO,MACRF=R                   *TASK*
FLAG1    DS    X                   X'01' if entry point at beginning
FLAG2    DS    X                   X'01' if LPA module
MASK10   DC    XL10'40202020202020202120'
DASHES   DS    0CL65
DASHEZ   DC    65C'-'
         SPACE 1
*IOPL     DS    0A                 IOPL FOR PUTLINE.
*IOPLUPT  DS    A                  POINTER TO USER PROFILE TABLE.
*IOPLECT  DS    A                  POINTER TO ENVIRONMENT CONTROL TAB.
*IOPLECB  DC    A(ECB)             POINTER TO ECB.
*IOPLIOPB DC    A(PTPB)            POINTER TO PTPB.
         SPACE 1
         SPACE 1
*PTPB     PUTLINE MF=L PUTLINE PARM. BLOCK.
         SPACE 1
MVMEM    MVC   MEMBER(*-*),0(R15)  *** EXECUTED ***
*VHEAD   MVC   0(*-*,R5),4(R9)     *** EXECUTED ***
MVHEAD   MVC   LINE(*-*),4(R9)     *** EXECUTED ***
TRT      TRT   0(*-*,R7),TRTAB     *** EXECUTED ***
BLANKS   DC    CL65' '
FULLZERO DC    F'0'
RULERL   DC    C'0----+----1----+----2----+----3----+----4----+----5---x
               -+----6----+----7----+----8----+----9----+----'
         SPACE 1
TRTAB    DC    256X'01'            TRT TABLE TO DETECT ...
         ORG   TRTAB+C'a'          ... NON-DISPLAY CHARACTERS.
         DC    9X'00'
         ORG   TRTAB+C'j'
         DC    9X'00'
         ORG   TRTAB+C's'
         DC    8X'00'
         ORG   TRTAB+C'A'
         DC    9X'00'
         ORG   TRTAB+C'J'
         DC    9X'00'
         ORG   TRTAB+C'S'
         DC    8X'00'
         ORG   TRTAB+C'0'
         DC    10X'00'
         ORG   TRTAB+X'4A'
         DC    7X'00'
         ORG   TRTAB+C'!'
         DC    8X'00'
         ORG   TRTAB+X'6A'
         DC    6X'00'
         ORG   TRTAB+C':'
         DC    6X'00'
         ORG   TRTAB+X'AF'
         DC    18X'00'
         ORG   TRTAB+C'\'
         DC    2X'00'
         ORG   TRTAB+C' '
         DC    X'00'
         ORG   ,
         SPACE 1
         LTORG
WORKFULL DS    0F
         DC    H'0'
WORKHALF DC    H'0'
         TITLE '- MESSAGES.'
MSG001   DC    C'Load module has non-standard header.'
MSG001L  EQU   *-MSG001
         SPACE 1
MSG002   DC    C'Cannot load '
MEMBER   DC    CL8' '              NAME OF MEMBER TO BE EXAMINED.
         DC    C' from any library in normal search path.'
MSG002L  EQU   *-MSG002
MSG003   DC    C'Beginning of CDE chain reached without a name match.'
MSG003L  EQU   *-MSG003
         TITLE '- Parse parameters.'
PPL      DS    0A                  PARSE PARM LIST.
PPLUPT   DS    A                   POINT TO UPT.
PPLECT   DS    A                   POINT TO ECT.
PPLECB   DC    A(ECB)              POINT TO ECB.
PPLPCL   DC    A(PCL)              POINT TO PCL.
PPLANS   DC    A(ANS)              POINT TO ANSWER PLACE.
PPLCBUF  DS    A                   POINT TO COMMAND BUFFER.
PPLWA    DC    A(0)                NO WORK AREA.
         SPACE 1
ANS      DS    A                   ANSWER PLACE.
ECB      DC    A(0)                COMMAND PROCESSOR ECB.
PCL      IKJPARM DSECT=PDL         PARSE PCL CSECT.
PDLLM    IKJIDENT 'Load Module',FIRST=ALPHA,OTHER=ALPHANUM,            +
               PROMPT='Load Module+',MAXLNTH=8,                        +
               HELP=('Name of load module to be listed.')
ENTRYKW  IKJKEYWD ,
         IKJNAME 'ENTRY'
NOHEXKW  IKJKEYWD ,
         IKJNAME 'NOHEX'
HEXKW    IKJKEYWD ,
         IKJNAME 'HEX'
*NOTITKW IKJKEYWD ,
*        IKJNAME 'NOTITLE'
         IKJENDP
HEX      DS    0H
         ST    R4,SAVER4A
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         L     R4,SAVER4A
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
SAVER4A  DS    F
HEXSAVE  DS    3F                    Register save for HEX macro
         DS    CL1
LINE     DS    CL200
TRTBL0   DS    0D
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'404040404040404040404A4B4C4D4E4F'
         DC    XL16'504040404040404040405A5B5C5D5E5F'
         DC    XL16'606140404040404040406A6B6C6D6E6F'
         DC    XL16'404040404040404040407A7B7C7D7E7F'
         DC    XL16'40818283848586878889404040404040'
         DC    XL16'40919293949596979899404040404040'
         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'
         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'
TRTBL1   DS    0D
         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'
         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'
         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'
         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'
         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'
         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'
         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'
         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'
         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'
         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'
         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'
         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'
         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'
         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'
         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'
         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'
TRTBL2   DS    0D
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         TITLE '- Mapping DSECTs.'
         PRINT GEN
         IKJCPPL                   MAP COMMAND PROCESSOR PARM LIST.
         CVT   DSECT=YES
         IKJTCB                                              *JUL-2014*
         IHACDE                                              *JUL-2014*
         IHAXTLST                                            *JUL-2014*
         PRINT NOGEN                                         *TASK*
         DCBD  DSORG=PO                                      *TASK*
         END   LISTMODD
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*  CLEANED A BIT  . . . 08/17
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATER  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUMENTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFORE R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   255                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
R3       EQU   3                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         EJECT
         IHAPSA   LIST=YES                                     HD APR88
         EJECT                                                 HD APR88
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
         DS    0D
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   R14,R12,12(R13)    SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES,SP=0       RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    R1,8(,R13)         OUR SAVE AREA POINTER
         ST    R13,4(,R1)         POINTER TO CALLER'S SAVE AREA
         LR    R13,R1             @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(,R13)        POINT TO CALLER'S RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 RC IF BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 RC IF BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(,RML)              MESSAGE LENGTH
         STH   R15,PUTLEN               PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(,R2)       @1ST PROBLEM PGM SAVE AREA
         L     R2,24(,R2)               REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    R2,R13                   @OUR SAVE AREA
         LR    R3,R15                   SAVE RETURN CODE
         L     R13,4(,R13)              @CALLER'S SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,R3                   RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLER'S REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END   EPUTL
